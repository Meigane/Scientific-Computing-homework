### 1. SOR 迭代法

#### 算法原理
SOR 是 Gauss-Seidel 方法的改进版本，引入松弛参数 ω 来加速收敛。

#### 迭代公式
对于第 i 个分量：

```
x_i⁽ᵏ⁺¹⁾ = (1-ω)x_i⁽ᵏ⁾ + (ω/a_ii)[b_i - Σ(j=1到i-1) a_ij·x_j⁽ᵏ⁺¹⁾ - Σ(j=i+1到n) a_ij·x_j⁽ᵏ⁾]
```

#### 关键点
- **前向使用新值**: j < i 时使用已更新的 x_j⁽ᵏ⁺¹⁾
- **后向使用旧值**: j > i 时使用上一轮的 x_j⁽ᵏ⁾
- **松弛参数**:
  - ω = 1: 退化为 Gauss-Seidel 方法
  - ω < 1: 低松弛
  - ω > 1: 超松弛（通常收敛更快）

#### 代码实现要点
```python
for i in range(n):
    # 前半部分：使用新值 x[:i]
    sigma1 = np.dot(A[i, :i], x[:i])
    
    # 后半部分：使用旧值 x_old[i+1:]
    sigma2 = np.dot(A[i, i+1:], x_old[i+1:])
    
    # SOR 更新
    x[i] = (1 - omega) * x_old[i] + omega / A[i, i] * (b[i] - sigma1 - sigma2)
```

---

### 2. CG (共轭梯度) 方法

#### 算法原理
CG 是专门用于求解对称正定线性方程组的高效迭代法。Hilbert 矩阵恰好是对称正定的。

#### 算法步骤
1. **初始化**:
   - r⁽⁰⁾ = b - Ax⁽⁰⁾  (初始残量)
   - p⁽⁰⁾ = r⁽⁰⁾        (初始搜索方向)

2. **每次迭代**:
   ```
   α_k = (r⁽ᵏ⁾, r⁽ᵏ⁾) / (p⁽ᵏ⁾, Ap⁽ᵏ⁾)
   x⁽ᵏ⁺¹⁾ = x⁽ᵏ⁾ + α_k · p⁽ᵏ⁾
   r⁽ᵏ⁺¹⁾ = r⁽ᵏ⁾ - α_k · Ap⁽ᵏ⁾
   β_k = (r⁽ᵏ⁺¹⁾, r⁽ᵏ⁺¹⁾) / (r⁽ᵏ⁾, r⁽ᵏ⁾)
   p⁽ᵏ⁺¹⁾ = r⁽ᵏ⁺¹⁾ + β_k · p⁽ᵏ⁾
   ```

#### 关键点
- **搜索方向的共轭性**: 保证在 A-范数意义下正交
- **理论收敛性**: 最多 n 步精确收敛（无舍入误差时）
- **实际应用**: 通常远少于 n 步就能达到所需精度

#### 代码实现要点
```python
# 计算步长 alpha
Ap = A @ p
alpha = np.dot(r, r) / np.dot(p, Ap)

# 更新解和残量
x = x + alpha * p
r_new = r - alpha * Ap

# 计算 beta（确保使用新旧残量）
beta = np.dot(r_new, r_new) / np.dot(r, r)

# 更新搜索方向
p = r_new + beta * p
```

---

## 收敛判断

### 相对残量公式
```
relres = ||b - Ax⁽ᵏ⁾||₂ / ||b||₂
```

### 收敛条件
- **收敛**: relres < tol (flag = 1)
- **不收敛**: 达到最大迭代次数仍未满足条件 (flag = 0)

---

### Q1: Hilbert 矩阵是什么？
A: Hilbert 矩阵是一个经典的病态矩阵，定义为:
```
H[i,j] = 1 / (i + j - 1),  i,j = 1,2,...,n
```
条件数随 n 增大而急剧增长，是测试数值算法稳定性的标准测试矩阵。

### Q2: 为什么要用相对残量而不是绝对残量？
A: 相对残量消除了问题规模的影响，使得不同问题之间的误差具有可比性。

### Q3: 如果不收敛怎么办？
A: 
- 增加最大迭代次数
- 调整 SOR 的松弛参数 ω
- 使用预条件技术

### Q4: CG 和 SOR 哪个更快？
A: 对于对称正定矩阵（如 Hilbert 矩阵），CG 通常收敛更快。但 Hilbert 矩阵的病态性可能影响两者的表现。

---


